import os
import json
import boto3
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, HttpUrl
from typing import List, Optional, Dict
from uuid import uuid4
from typing import Tuple
from datetime import datetime

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://127.0.0.1:5173",
        "http://localhost:5173",
    ],
    allow_credentials=True,
    allow_methods=["*"],   # <-- this is what lets OPTIONS through
    allow_headers=["*"],
)


class PsychoMetadata(BaseModel):
    # Generated by the model/service, NOT by the user.
    day_residues: Optional[List[str]] = None
    wish_fulfillment_type: Optional[str] = None  # "satisfied" | "blocked" | "unclear"
    key_signifiers: Optional[List[str]] = None   # e.g. ["corridor", "mirror", "train"]
    subject_position: Optional[str] = None       # "agent" | "passive" | "observer" | etc.
    register_feel: Optional[str] = None          # "symbolic" | "imaginary" | "real"


class DreamCreate(BaseModel):
    # LEFT PAGE: daily context
    mood: Optional[int] = None                # -3 (very bad) to +3 (very good)
    sleep_quality: Optional[int] = None       # 1–5
    context_note: Optional[str] = None        # free text: "argued with X, crammed for exam"

    mbti: Optional[str] = None                # e.g. "INFJ"

    spotify_url: Optional[HttpUrl] = None
    letterboxd_url: Optional[HttpUrl] = None
    goodreads_url: Optional[HttpUrl] = None

    listening_to: Optional[str] = None        # "Weird ambient playlist, artist X"
    watching: Optional[str] = None            # "Rewatching Mulholland Drive"
    reading: Optional[str] = None             # "Finishing The Secret History"

    # RIGHT PAGE: dream itself
    title: Optional[str] = None
    narrative: str


class Dream(DreamCreate):
    id: str
    created_at: datetime


class DreamRenderResponse(BaseModel):
    dream: Dream
    style_profile: Dict
    movie_script: str
    psychoanalysis: str
    psycho_metadata: Optional[PsychoMetadata] = None


# In-memory store (Step 1 only)
dreams_db: Dict[str, Dream] = {}


# =======================
# Inference service
# =======================

def build_style_profile(dream: Dream) -> Dict:
    """Map dream + journal context into cinematic style components."""
    # Color palette based on mood
    if dream.mood is not None and dream.mood >= 2:
        palette = ["warm gold", "soft peach", "sky blue"]
    elif dream.mood is not None and dream.mood <= -2:
        palette = ["deep blue", "charcoal gray", "neon accent"]
    else:
        # neutral / unknown mood
        palette = ["muted plum", "off-white", "faded orange"]

    # Camera style based on sleep quality
    camera_style = "static shots with occasional push-ins"
    if dream.sleep_quality is not None and dream.sleep_quality <= 2:
        camera_style = "handheld, slightly shaky, close on faces"
    elif dream.sleep_quality is not None and dream.sleep_quality >= 4:
        camera_style = "slow tracking shots, gentle pans"

    media_lines: List[str] = []

    if dream.listening_to:
        media_lines.append(
            f"the rhythm of cuts echoes what you were listening to ({dream.listening_to})."
        )
    if dream.watching:
        media_lines.append(
            f"the visual grammar borrows from what you were watching ({dream.watching})."
        )
    if dream.reading:
        media_lines.append(
            f"narrative motifs echo what you were reading ({dream.reading})."
        )

    # MBTI flavor
    mbti = (dream.mbti or "").upper()
    if "N" in mbti:
        camera_style += " Occasional surreal, lingering shots suggest intuitive leaps."
    if "S" in mbti:
        media_lines.append("the film lingers on textures and small sensory details.")
    if "F" in mbti:
        media_lines.append("close-ups emphasize emotional expressions.")
    if "T" in mbti:
        media_lines.append("compositions feel precise, almost architected.")

    return {
        "colorPalette": palette,
        "cameraStyle": camera_style,
        "mediaInfluence": media_lines,
        "mbti": dream.mbti,
        "links": {
            "spotify": dream.spotify_url,
            "letterboxd": dream.letterboxd_url,
            "goodreads": dream.goodreads_url,
        },
    }


def generate_psychoanalysis(
    dream: Dream,
    style_profile: Dict
) -> Tuple[str, PsychoMetadata]:
    """
    Freud/Lacan-flavored reflection.

    For now this is heuristic; later this is where you'd call Bedrock and let
    the model infer psycho_metadata + analysis from the dream + journal context.
    """
    text = dream.narrative.lower()

    imaginary_words = ["mirror", "reflection", "double", "face", "body", "image"]
    symbolic_words = ["exam", "test", "school", "university", "office", "manager", "contract", "email", "rules"]
    real_words = ["blood", "wound", "dead", "scream", "void", "teeth", "falling", "crash"]

    found_signifiers: List[str] = []
    for word in imaginary_words + symbolic_words + real_words:
        if word in text:
            found_signifiers.append(word)

    register: Optional[str] = None
    if any(w in text for w in imaginary_words):
        register = "imaginary"
    if any(w in text for w in symbolic_words):
        register = "symbolic"
    if any(w in text for w in real_words):
        register = "real"

    psycho_meta = PsychoMetadata(
        key_signifiers=found_signifiers or None,
        register_feel=register,
    )

    points: List[str] = []

    if register == "imaginary":
        points.append(
            "The dream feels strongly Imaginary in the Lacanian sense: centered on bodies, images, and questions of self-image."
        )
    elif register == "symbolic":
        points.append(
            "Symbolic elements dominate: exams, institutions, or obligations act as the scaffolding of the dream."
        )
    elif register == "real":
        points.append(
            "There are flashes of the Real: intrusive moments that feel too intense or senseless to be fully integrated into the narrative."
        )

    if found_signifiers:
        uniq = ", ".join(sorted(set(found_signifiers)))
        points.append(
            f"Certain signifiers repeat with weight in the scene (for example: {uniq}), "
            "hinting at knots where desire, fear, and memory intersect."
        )

    if dream.mbti:
        points.append(
            f"Read alongside your MBTI type ({dream.mbti.upper()}), the dream can also be seen as a way your temperament stages conflict and desire in images."
        )

    if dream.context_note:
        points.append(
            f"The context you noted for this day ('{dream.context_note}') "
            "seeps into the dream's atmosphere rather than appearing directly."
        )

    if not points:
        points.append(
            "This dream can be read as an interplay of residues from the day and longer-standing patterns of desire, "
            "but its more precise meaning will emerge as you compare it with other dreams over time."
        )

    analysis_text = " ".join(points)
    return analysis_text, psycho_meta


def generate_movie_script(dream: Dream, style_profile: Dict) -> str:
    """Render the dream as a short film description."""
    palette = ", ".join(style_profile["colorPalette"])
    camera = style_profile["cameraStyle"]
    media_inf = style_profile["mediaInfluence"]
    media_sentence = (
        " ".join(media_inf) if media_inf else
        "The film feels detached from explicit media, as if emerging purely from your inner world."
    )

    narrative = dream.narrative.strip().replace("\n", " ")

    return (
        f"The dream film opens in a palette of {palette}. "
        f"The camera moves with {camera} "
        f"{media_sentence} "
        f"The sequence follows your dream: {narrative}"
    )


def run_dream_inference(dream: Dream) -> DreamRenderResponse:
    """
    This is your 'Bedrock model container' abstraction.
    For now it's local Python; later this calls a Bedrock endpoint.
    """
    style = build_style_profile(dream)
    analysis_text, psycho_meta = generate_psychoanalysis(dream, style)
    script = generate_movie_script(dream, style)
    return DreamRenderResponse(
        dream=dream,
        style_profile=style,
        movie_script=script,
        psychoanalysis=analysis_text,
        psycho_metadata=psycho_meta,
    )


# =======================
# API endpoints
# =======================

@app.get("/health")
def health():
    return {"status": "ok"}


@app.post("/dreams", response_model=Dream)
def create_dream(payload: DreamCreate):
    """
    Create a dream journal entry.
    Left page: mood/MBTI/links/listening/watching/reading/context_note.
    Right page: title + narrative.
    """
    dream_id = str(uuid4())
    dream = Dream(
        id=dream_id,
        created_at=datetime.utcnow(),
        **payload.dict(),
    )
    dreams_db[dream_id] = dream
    return dream


@app.get("/dreams/{dream_id}", response_model=Dream)
def get_dream(dream_id: str):
    dream = dreams_db.get(dream_id)
    if not dream:
        raise HTTPException(status_code=404, detail="Dream not found")
    return dream


@app.get("/dreams", response_model=List[Dream])
def list_dreams():
    """
    List all dreams – you can use this for the dreamy calendar view.
    """
    # You can sort by created_at if you want:
    return sorted(dreams_db.values(), key=lambda d: d.created_at)


@app.post("/dreams/{dream_id}/render", response_model=DreamRenderResponse)
def render_dream(dream_id: str):
    """
    Turn the journal entry into a 'film':
    - style_profile (cinematic parameters, MBTI + mood + what you watched/listened/read)
    - movie_script (short film description)
    - psychoanalysis (interpretation text)
    - psycho_metadata (model-inferred Lacanian/Freudian-ish fields)
    """
    dream = dreams_db.get(dream_id)
    if not dream:
        raise HTTPException(status_code=404, detail="Dream not found")

    result = run_dream_inference(dream)
    return result